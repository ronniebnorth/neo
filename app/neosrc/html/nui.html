<script>
'use strict';

/** Extending the default Text object to support some neo element properties. */
Object.defineProperty(Text.prototype, 'root', {
  get: function () {
    return 'root' in this.parentElement ? this.parentElement.root : null;
  }
});

Object.defineProperty(Text.prototype, 'range', {
  get: function () {
    var range = new Range();

    range.setStart(this, 0);
    range.setEnd(this, this.textContent.length);

    return range;
  }
});

/** Root class for all Neo custom elements. Contains helpers to facilitate
document editing tasks. */
class NeoElement extends PhElement {
  constructor() {
    super();
  }

  get root() {
    var root = null;
    var node = this;

    while (node) {
      if (node.nodeType == Node.ELEMENT_NODE) {
        if (node.isContent) {
          root = node;
        }
      }

      node = node.parentNode;
    }

    return root;
  }

  get isContent() {
    return this.tagName.startsWith('NEO-');
  }

  get isFirstContent() {
    return this.isContent && this.parentNode === this.root && !this.previousSibling;
  }

  get isLastContent() {
    return this.isContent && this.parentNode == this.root && !this.nextSibling;
  }

  get isUI() {
    return this.tagName.startsWith('NUI-');
  }

  get hasNeoParent() {
    var parent = this.parentNode;

    return parent && (parent.isContent || parent.isUI)
  }

  get contentParent() {
    // !!!LATER!!! this will be necessary when we add style elements (e.g. <b>, <i>, etc.)
    var node = this.parentNode;

    while (node && !node.isContent) {
      node = node.parentNode;
    }

    return node;
  }

  get docLast() {
    var node = this;

    while (node.lastChild) {
      node = node.lastChild;
    }

    return node;
  }

  get docFirst() {
    var node = this;

    while (node.firstChild) {
      node = node.firstChild;
    }

    return node;
  }

  get docPrev() {
    if (this.isFirstContent) {
      return null;
    }

    if (this.previousSibling) {
      return this.previousSibling;
    }

    var node = this;

    while (node.hasNeoParent && !node.previousSibling) {
      node = node.parentNode;
    }

    return node.previousSibling && node.previousSibling.docLast;
  }

  get docNext() {
    if (this.isLastContent) {
      return null;
    }

    if (this.nextSibling) {
      return this.nextSibling;
    }

    var node = this;

    while (node.hasNeoParent && !node.nextSibling) {
      node = node.parentNode;
    }

    return node.nextSibling && node.nextSibling.docFirst;
  }

  get cursor() {
    return this.root && this.root.querySelector('nui-cursor');
  }

  get anchor() {
    return this.root && this.root.querySelector('nui-anchor');
  }

  get selectionRange() {
    var cursorRange = this.cursor && this.cursor.range;
    var anchorRange = this.anchor && this.anchor.range;

    if (!cursorRange || !anchorRange) {
      return null;
    }

    var dir = cursorRange.compareBoundaryPoints(Range.END_TO_END, anchorRange);
    var range = new Range();
    range.startLocation = dir < 0 ? cursorRange.endLocation : anchorRange.endLocation;
    range.endLocation = dir < 0 ? anchorRange.startLocation : cursorRange.startLocation;

    return range;
  }

  get range() {
    var range = new Range();

    range.setStartBefore(this);
    range.setEndAfter(this);

    return range;
  }

  rangeFromPoint(x, y) {
    var range = document.caretRangeFromPoint(x, y);

    if (!range) {
      return null;
    }

    var node = range.startContainer;

    if (node.root) {
      return range;
    }

    if (node.nodeType == Node.TEXT_NODE) {
      node = node.parentElement;
    }

    var ow = $(node).width();
    $(node).width(0);

    var nr = this.rangeFromPoint(x, y);

    $(node).width(ow);

    return nr;
  }

  findProperty(name) {
    if (this[name] !== undefined) {
      return this[name];
    }

    return this.hasNeoParent ? this.parentNode.findProperty(name) : null;
  }

  normalizeContent() {
    var nl = this.childNodes;
    var i = 1;

    while (i < nl.length) {
      if (nl[i].nodeType == Node.TEXT_NODE && nl[i-1].nodeType == Node.TEXT_NODE) {
        nl[i-1].textContent += nl[i].textContent;
        nl[i].parentNode.removeChild(nl[i]);
      } else {
        i++;
      }
    }
  }

  syncSelection() {
    var sel = window.getSelection();
    var sr = this.selectionRange;

    sel.empty();

    if (sr) {
      sel.addRange(sr);
    }
  }

  cursorLeft() {
    var cursor = this.cursor;
    var prev = cursor.docPrev;

    if (!prev) {
      return;
    }

    if (cursor.parentNode == prev.parentNode) {
      if (prev.nodeType == Node.TEXT_NODE && prev.textContent.length > 1) {
        var range = new Range();
        range.location = {container: prev, position: prev.textContent.length-1};
        range.insertNode(cursor);
      } else {
        prev.parentNode.insertBefore(cursor, prev);
      }
    } else {
      prev.parentNode.appendChild(cursor);
    }

    cursor.contentParent.normalizeContent();
  }

  cursorRight() {
    var cursor = this.cursor;
    var next = cursor.docNext;

    if (!next) {
      return;
    }

    if (cursor.parentNode == next.parentNode) {
      if (next.nodeType == Node.TEXT_NODE && next.textContent.length > 1) {
        var range = new Range();
        range.location = {container: next, position: 1};
        range.insertNode(cursor);
      } else {
        next.parentNode.insertBefore(cursor, next.nextSibling);
      }
    } else {
      next.parentNode.insertBefore(cursor, next);
    }

    cursor.contentParent.normalizeContent();
  }

  _moveCursorVertical(dir) {
    var cursor = this.cursor;

    var point  = $(cursor).offset();
    if ('lastLineLeft' in cursor) {
      log.debug('lastLineLeft', cursor.lastLineLeft);
      point.left = cursor.lastLineLeft;
    }
    point.top = dir < 0 ? point.top - 1 : point.top + $(cursor).height();

    var checkEl = dir < 0 ? cursor.docPrev : cursor.docNext;

    if (!checkEl) {
      return;
    }

    var checkRange = checkEl.range;
    if (dir < 0) {
      checkRange.collapseToEnd();
    } else {
      checkRange.collapseToStart();
    }

    var range = this.rangeFromPoint(point.left, point.top);
    var cr = cursor.root.lastElementChild.getBoundingClientRect();

    while ((point.top >= 0 && point.top < cr.top + cr.height)
          && (range
                && (range.compareBoundaryPoints(Range.END_TO_START, checkRange) * dir  <= 0
                      || ((range.startContainer.nodeType == Node.TEXT_NODE && range.startOffset === 0) && point.left > 0)
                    )
             )
        ) {
      point.top += dir;
      range = this.rangeFromPoint(point.left, point.top);
    }

    if (range) {
      log.debug(range.startContainer.textContent, range.startOffset);
      cursor = cursor.parentNode.removeChild(cursor);
      range.insertNode(cursor);
      cursor.lastLineLeft = point.left;

      cursor.contentParent.normalizeContent();
    }
  }

  cursorUp() {
    this._moveCursorVertical(-1);
  }

  cursorDown() {
    this._moveCursorVertical(1);
  }

  insert(data) {
    var cursor = this.cursor;
    var previous = cursor.previousSibling;

    if (previous) {
      previous.nodeValue = previous.nodeValue + data;
    } else {
      var tn = document.createTextNode(data);
      cursor.parentNode.insertBefore(tn, cursor);
    }
  }

  backspace() {
    var cursor = this.cursor;
    var prev = cursor.previousSibling;

    if (prev) {
      switch (prev.nodeType) {
        case Node.TEXT_NODE: {
          if (prev.nodeValue.length > 1) {
            prev.nodeValue = prev.nodeValue.substring(0, prev.nodeValue.length-1);
          } else {
            prev.parentNode.removeChild(prev);
          }
        } break;

        case Node.ELEMENT_NODE: {
          if (prev.isContent) {
            var range = new Range();
            range.selectNodeContents(prev);
            range.collapseToEnd();

            cursor = cursor.parentNode.removeChild(cursor);
            range.insertNode(cursor);
          } else {
            prev.parentNode.removeChild(prev);
          }
        }
      }
    } else {
      var parent = cursor.parentNode;

      if (!parent.isFirstContent) {
        if (parent.textContent.trim().length <= 0) {
          var docPrev = cursor.docPrev;

          if (docPrev.isContent) {
            docPrev.append(cursor.parentNode.removeChild(cursor));
          } else {
            docPrev.parentNode.append(cursor.parentNode.removeChild(cursor));
          }

          parent.parentNode.removeChild(parent);
        } else {
          if (parent.previousSibling) {
            parent.previousSibling.append.apply(parent.previousSibling, Array.from(parent.childNodes));
            parent.parentNode.removeChild(parent);
          } else {
            // !!!TODO!!! find next previous position
            log.warn('backspace: handle hierarchical content')
          }
        }
      }
    }
  }

  lineBreak() {
    var cursor = this.cursor;
    var nextContainer = cursor.findProperty('nextContainer');
    var parent = cursor.contentParent;
    var range = new Range();
    range.selectNodeContents(parent);
    range.setStartBefore(cursor);

    var newNode = document.createElement(nextContainer);
    newNode.appendChild(range.extractContents());
    parent.parentNode.insertBefore(newNode, parent.nextSibling);
  }
}


Range.prototype.collapseToStart = function () {
  this.collapse(true);
}

Range.prototype.collapseToEnd = function () {
  this.collapse(false);
}

Range.prototype.shiftLocation = (location, chars) => {
  var node = location.container;
  var dir = Math.sign(chars);

  while (chars > 0) {
    switch (node.nodeType) {
      case Node.ELEMENT_NODE: {

      } break;
      case Node.TEXT_NODE: {

      } break;
    }
  }
}

Object.defineProperty(Range.prototype, 'location', {
  get: function () {
    return this.startLocation;
  },

  set: function (newLocation) {
    this.startLocation =
    this.endLocation = newLocation;
  }
});

Object.defineProperty(Range.prototype, 'startLocation', {
  get: function () {
    return {container: this.startContainer, position: this.startOffset};
  },

  set: function (newLocation) {
    this.setStart(newLocation.container, newLocation.position);
  }
});

Object.defineProperty(Range.prototype, 'endLocation', {
  get: function () {
    return {container: this.endContainer, position: this.endOffset};
  },

  set: function (newLocation) {
    this.setEnd(newLocation.container, newLocation.position);
  }
});
</script>
<ph-components>
  <template name="nui-stage">
    <style>
      :host {
        display: block;
      }

      ::content>* {
        visibility: hidden;
      }
      ::content>*.active {
        visibility: visible;
      }
    </style>
    <content></content>
  </template>

  <template name="nui-pane">
    <style>
      :host {
        position: absolute;
        top: 0;
        left: 0;

        width: 100%;
        height: 100%;

        background-color: #fff;

        text-align: center;
      }
    </style>
    <content></content>
  </template>
</ph-components>
