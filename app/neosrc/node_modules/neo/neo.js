'use strict';

const path = require('path');
const fs = require('fs-extra');

const electron = require('electron');

const log = require('log');
const au = require('apputil');

/**
 *  Main shared module for neo word processor.
 *
 *  @module neo
 */

var _neoRoot;
var _CurrentUser = null;
var _CurrentAuthor = null;
var _CurrentStory  = null;
var _CurrentTab = null;
var _StoryPane = null;
var _BookcasePane = null;
var _Tabs = {};
var _Commands = [];
var _CommandsByName = {};

var self = module.exports = {
  get name() { return 'neo'; },

  /** Class representing the neo user. There can be only one user, but a single
  user can have many Author profiles. */
  get User() { return require('./User.js'); },

  /** Class representing a neo author. */
  get Author() { return require('./Author.js'); },

  /** Class representing a neo story. */
  get Story() { return require('./Story.js'); },

  /** Class representing bookcase of all available stories. */
  get Bookcase() { return require('./Bookcase.js'); },

  /** Current neo root folder. This is the container for all User, Author, and
  Story data. */
  get neoRoot() {
    return _neoRoot;
  },

  set neoRoot(newRoot) {
    _neoRoot = newRoot;
    log.debug('new neo root: ' + newRoot);
    loadRoot(_neoRoot);
  },

  /** Default story folder. */
  get StoryFolder() {
    var folder = path.join(_neoRoot, '/docs');
    fs.ensureDirSync(folder);

    return folder;
  },

  /** Authors folder. */
  get AuthorsFolder() {
    var folder = path.join(_neoRoot, '/authors');
    fs.ensureDirSync(folder);

    return folder;
  },

  /** Current active user profile. */
  get CurrentUser() {
    return _CurrentUser;
  },

  set CurrentUser(newUser) {
    _CurrentUser = newUser;

    fs.writeJsonSync(path.join(_neoRoot, '/user.nuf'), _CurrentUser);
  },

  /** Current active author profile. */
  get CurrentAuthor() {
    return _CurrentAuthor || _CurrentUser.DefaultAuthor;
  },

  set CurrentAuthor(newAuthor) {
    _CurrentAuthor = newAuthor;
  },

  /** Current active story. */
  get CurrentStory() {
    return _CurrentStory;
  },

  set CurrentStory(newStory) {
    this.CurrentTab = null;
    document.dispatchEvent(new CustomEvent('closing_story', {detail: {story: _CurrentStory}}));
    _CurrentStory = newStory;
    if (_CurrentStory) {
      document.dispatchEvent(new CustomEvent('open_story', {detail: {story: _CurrentStory}}));
    }
  },

  /** Current active tab. */
  get CurrentTab() {
    return _CurrentTab;
  },

  set CurrentTab(newTab) {
    if (_CurrentTab) {
      document.dispatchEvent(new CustomEvent('closing_tab', {detail: {tab: _CurrentTab}}));
      _CurrentTab.closeTab && _CurrentTab.closeTab();
    }

    if (typeof newTab == 'string') {
      newTab = this.Tabs[newTab];
    }

    _CurrentTab = newTab;
    document.dispatchEvent(new CustomEvent('open_tab', {detail: {tab: _CurrentTab}}));
    _CurrentTab && _CurrentTab.openTab && _CurrentTab.openTab();
  },

  /** Pane where current story will be displayed/edited. */
  get StoryPane() {
    return _StoryPane;
  },

  set StoryPane(newPane) {
    _StoryPane = newPane;
  },

  /** Pane where bookcase will be displayed. */
  get BookcasePane() {
    return _BookcasePane;
  },

  set BookcasePane(newPane) {
    _BookcasePane = newPane;
  },

  /** All loaded tabs. */
  get Tabs() {
    return _Tabs;
  },

  get Commands() {
    return _Commands;
  },

  get CommandStats() {
    return this.CurrentUser.getPref('neo.command_stats') || {commands: {}, matches: {}};
  },

  set CommandStats(newStats) {
    this.CurrentUser.setPref('neo.command_stats', newStats);
  },

  getPref(key) {
    var prefSources = [this.CurrentStory, this.CurrentAuthor, this.CurrentUser];

    for (var i = 0; i < prefSources.length; i++) {
      if (prefSources[i] && prefSources[i].getPref(key) != undefined) {
        return prefSources[i].getPref(key);
      }
    }

    return undefined;
  },

  registerCommands(module, commands) {
    _Commands = _Commands.concat(commands.map((cmd) => {
      cmd.module = module;

      if (cmd.name in _CommandsByName) {
        log.warn('module ' + module.name + ' attempted to register duplicate command "' + cmd.name + '"');
      } else {
        _CommandsByName[cmd.name] = cmd;
      }

      return cmd;
    }));
  },

  matchCommands(searchString) {
    if (!searchString) {
      return [];
    }

    var matches = _Commands.filter(command => {
      return command.name.indexOf(searchString) >= 0;
    });

    var stats = this.CommandStats;

    function scoreCommand(command) {
      if (command.name in stats.commands) {
        if (searchString in stats.commands[command.name]) {
          return stats.commands[command.name][searchString];
        }
      }

      var wa = command.name.split();
      for (var w in wa) {
        var i = w.indexOf(searchString);

        if (i >= 0) {
          // !!!LATER!!! make the default scoring algorithm prefer letters
          // closer to the start of individual words rather than the whole
          // command name
          return 1.0 - (i / w.length);
        }
      }

      return 0;
    }

    matches.sort((a, b) => {
      return scoreCommand(b) - scoreCommand(a);
    });

    return matches;
  },

  execCommand(commandName, heuristics) {
    if (!(commandName in _CommandsByName)) {
      log.error('attempt to execute unknown command "' + commandName + '"');

      return;
    }

    var cmd = _CommandsByName[commandName];
    cmd.fn && cmd.fn.call(cmd.module);

    this._updateCommandStats(commandName, heuristics);
  },

  _updateCommandStats(commandName, heuristics) {
    var stats = this.CommandStats;

    au.addTally(stats.commands, [commandName, heuristics.searchString]);
    au.addTally(stats.matches, [heuristics.searchString, commandName]);

    this.CommandStats = stats;
  }
}

function loadRoot(root) {
  fs.ensureDirSync(root);
  try {
    _CurrentUser = new self.User(path.join(root, '/user.nuf'));

    _Tabs = {};
    _Commands = [];

    // load built-in tabs
    loadTabs(path.join(__dirname, 'tabs'));

    // load install-specific tabs
    loadTabs(path.join(root, 'tabs'));
  } catch (e) {
    log.error('unable to load neo root', e);
  }
}

function loadTabs(tabRoot) {
  if (!fs.pathExistsSync(tabRoot)) {
    return;
  }

  fs.readdirSync(tabRoot).forEach(tabName => {
    try {
      if (!(tabName in _Tabs)) {
        var tabFolder = path.join(tabRoot, tabName);
        if (fs.lstatSync(tabFolder).isDirectory()) {
          _Tabs[tabName] = require(tabFolder);
          if (_Tabs[tabName].Commands) {
            self.registerCommands(_Tabs[tabName], _Tabs[tabName].Commands);
          }
          log.debug('tab ' + tabName + ' loaded');
        }
      } else {
        log.warn('not loading tab ' + tabName + ': conflict with built-in tab');
      }
    } catch (e) {
      log.error('unable to load tab ' + tabName, e);
    }
  });
}
