'use strict';

const path = require('path');
const fs = require('fs-extra');

const electron = require('electron');

const log = require('log');

/**
 *  Main shared module for neo word processor.
 *
 *  @module neo
 */

var _neoRoot;
var _CurrentUser = null;
var _CurrentAuthor = null;
var _CurrentStory  = null;
var _CurrentTab = null;
var _StoryPane = null;
var _BookcasePane = null;
var _Tabs = {};
var _Commands = [];

var self = module.exports = {
  /** Class representing the neo user. There can be only one user, but a single
  user can have many Author profiles. */
  get User() { return require('./User.js'); },

  /** Class representing a neo author. */
  get Author() { return require('./Author.js'); },

  /** Class representing a neo story. */
  get Story() { return require('./Story.js'); },

  /** Class representing bookcase of all available stories. */
  get Bookcase() { return require('./Bookcase.js'); },

  /** Current neo root folder. This is the container for all User, Author, and
  Story data. */
  get neoRoot() {
    return _neoRoot;
  },

  set neoRoot(newRoot) {
    _neoRoot = newRoot;
    log.debug('new neo root: ' + newRoot);
    loadRoot(_neoRoot);
  },

  /** Default story folder. */
  get StoryFolder() {
    var folder = path.join(_neoRoot, '/docs');
    fs.ensureDirSync(folder);

    return folder;
  },

  /** Authors folder. */
  get AuthorsFolder() {
    var folder = path.join(_neoRoot, '/authors');
    fs.ensureDirSync(folder);

    return folder;
  },

  /** Current active user profile. */
  get CurrentUser() {
    return _CurrentUser;
  },

  set CurrentUser(newUser) {
    _CurrentUser = newUser;

    fs.writeJsonSync(path.join(_neoRoot, '/user.nuf'), _CurrentUser);
  },

  /** Current active author profile. */
  get CurrentAuthor() {
    return _CurrentAuthor || _CurrentUser.DefaultAuthor;
  },

  set CurrentAuthor(newAuthor) {
    _CurrentAuthor = newAuthor;
  },

  /** Current active story. */
  get CurrentStory() {
    return _CurrentStory;
  },

  set CurrentStory(newStory) {
    this.CurrentTab = null;
    document.dispatchEvent(new CustomEvent('closing_story', {detail: {story: _CurrentStory}}));
    _CurrentStory = newStory;
    document.dispatchEvent(new CustomEvent('open_story', {detail: {story: _CurrentStory}}));
  },

  /** Current active tab. */
  get CurrentTab() {
    return _CurrentTab;
  },

  set CurrentTab(newTab) {
    if (_CurrentTab) {
      document.dispatchEvent(new CustomEvent('closing_tab', {detail: {tab: _CurrentTab}}));
      _CurrentTab.closeTab && _CurrentTab.closeTab();
    }

    if (typeof newTab == 'string') {
      newTab = this.Tabs[newTab];
    }

    _CurrentTab = newTab;
    document.dispatchEvent(new CustomEvent('open_tab', {detail: {tab: _CurrentTab}}));
    _CurrentTab && _CurrentTab.openTab && _CurrentTab.openTab();
  },

  /** Pane where current story will be displayed/edited. */
  get StoryPane() {
    return _StoryPane;
  },

  set StoryPane(newPane) {
    _StoryPane = newPane;
  },

  /** Pane where bookcase will be displayed. */
  get BookcasePane() {
    return _BookcasePane;
  },

  set BookcasePane(newPane) {
    _BookcasePane = newPane;
  },

  /** All loaded tabs. */
  get Tabs() {
    return _Tabs;
  },

  get Commands() {
    return _Commands;
  },

  getPref(key) {
    var prefSources = [this.CurrentStory, this.CurrentAuthor, this.CurrentUser];

    for (var prefSource in prefSources) {
      if (prefSource && prefSource.getPref(key) != undefined) {
        return prefSource.getPref(key);
      }
    }

    return undefined;
  },

  registerCommands(module, commands) {
    _Commands = _Commands.concat(commands.map((cmd) => {
      cmd.module = module;

      return cmd;
    }));
  }
}

function loadRoot(root) {
  fs.ensureDirSync(root);
  try {
    _CurrentUser = new self.User(path.join(root, '/user.nuf'));

    _Tabs = {};
    _Commands = [];

    // load built-in tabs
    loadTabs(path.join(__dirname, 'tabs'));

    // load install-specific tabs
    loadTabs(path.join(root, 'tabs'));
  } catch (e) {
    log.error('unable to load neo root', e);
  }
}

function loadTabs(tabRoot) {
  if (!fs.pathExistsSync(tabRoot)) {
    return;
  }

  fs.readdirSync(tabRoot).forEach(tabName => {
    try {
      if (!(tabName in _Tabs)) {
        var tabFolder = path.join(tabRoot, tabName);
        if (fs.lstatSync(tabFolder).isDirectory()) {
          _Tabs[tabName] = require(tabFolder);
          if (_Tabs[tabName].Commands) {
            self.registerCommands(tabName, _Tabs[tabName].Commands);
          }
          log.debug('tab ' + tabName + ' loaded');
        }
      } else {
        log.warn('not loading tab ' + tabName + ': conflict with built-in tab');
      }
    } catch (e) {
      log.error('unable to load tab ' + tabName, e);
    }
  });
}
