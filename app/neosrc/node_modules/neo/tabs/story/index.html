<ph-components>
  <template name="story-editor">
    <style>
      :host {
        background-color: #fff;

        text-align: left;

        overflow-x: hidden;
        overflow-y: scroll;

        display: block;
        height: 100%;

        padding: 1em;
      }
    </style>
    <content></content>
    <script>
      class StoryEditor extends PhElement {
        constructor() {
          super();
        }

        connectedCallback() {
          super.connectedCallback();

          this.setAttribute('tabindex', '0');

          $(this).on('keydown keyup keypress', this._handleKeyEvent);
          $(this).on('beforeinput input', this._handleInputEvent);

          var cursor = $(this).find('nui-cursor')[0];

          if (!cursor) {
            log.warn('missing nui-cursor element in document: creating default cursor');

            cursor = document.createElement('nui-cursor');
            var node = this.firstChild.firstChild;

            while (node && (!node.isContent || node === node.root)) {
              node = node.docNext;
            }

            if (node) {
              node.appendChild(cursor);
            } else {
              log.warn('unable to place cursor: corrupt document');
            }
          }

          cursor.syncSelection();

          $(this).on('focus', e => $(this).find('nui-cursor').focus());
        }

        disconnectedCallback() {
          this.save();

          var sel = window.getSelection();
          sel.empty();
        }

        get story() {
          return this._story;
        }

        set story(newStory) {
          this._story = newStory;
          $(this).html(this.story.story.body);
        }

        get doc() {
          return $(this).find('*')[0];
        }

        save() {
          if (!this.story) {
            return;
          }

          this.story.story.body = $(this).html();
          this.story.write();
        }

        _handleKeyEvent(e) {
          var pke = keyboard.processKeyEvent(e.originalEvent);

          if (pke.type == 'keypress' && pke.isData) {
            this.doc.insert(pke.data);
          }

          if (pke.isCommand) {
            if ('_Command' + pke.command in this) {
              if (this['_Command' + pke.command](pke)) {
                e.preventDefault();

                return false;
              }
            }
          }
        }

        _handleInputEvent(e) {
          console.log('editor handling input event', e);
        }

        _CommandBackspace(pke) {
          if (pke.originalEvent.type != 'keydown' || pke.hasModifier) {
            return false;
          }

          this.doc.backspace();

          return true;
        }

        _CommandArrowLeft(pke) {
          if (pke.originalEvent.type != 'keydown') {
            return false;
          }

          this.doc.cursorLeft();

          return true;
        }

        _CommandArrowRight(pke) {
          if (pke.originalEvent.type != 'keydown') {
            return false;
          }

          this.doc.cursorRight();

          return true;
        }

        _CommandArrowUp(pke) {
          if (pke.originalEvent.type != 'keydown' || pke.hasModifier) {
            return false;
          }

          this.doc.cursorUp();

          return true;
        }

        _CommandArrowDown(pke) {
          if (pke.originalEvent.type != 'keydown' || pke.hasModifier) {
            return false;
          }

          this.doc.cursorDown();

          return true;
        }

        _CommandHome(pke) {
          if (pke.originalEvent.type != 'keydown' || pke.hasModifier) {
            return false;
          }

          this.doc.cursorHome();

          return true;
        }

        _CommandEnd(pke) {
          if (pke.originalEvent.type != 'keydown' || pke.hasModifier) {
            return false;
          }

          this.doc.cursorEnd();

          return true;
        }

        _CommandEnter(pke) {
          if (pke.originalEvent.type != 'keydown') {
            return false;
          }

          this.doc.lineBreak();

          return true;
        }

        _CommandShift(pke) {
          switch (pke.originalEvent.type) {
            case 'keydown': {
              this.doc.weighAnchor();
              if (!this.doc.anchor) {
                this.doc.dropAnchor();
              }
            } break;

            case 'keyup': {
              if (!this.doc.selectionRange) {
                this.doc.weighAnchor();
              }
            } break;
          }

          return false;
        }

        _CommandEscape(pke) {
          if (pke.originalEvent.type) {
            if (this.doc.anchor) {
              this.doc.weighAnchor();
            }
          }
        }
      }
    </script>
  </template>
</ph-components>
